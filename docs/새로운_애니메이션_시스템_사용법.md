# 🎬 새로운 통합 애니메이션 시스템 사용법

## 📋 개요

레스토랑 웹사이트의 애니메이션 시스템을 완전히 리팩토링하여 다음과 같은 장점을 얻었습니다:

### ✅ 주요 개선사항
- **중앙집중식 관리**: 모든 애니메이션 설정이 한 곳에서 관리됨
- **재사용성 향상**: Hook 기반의 모듈화된 애니메이션 로직
- **성능 최적화**: 불필요한 리렌더링 방지 및 메모리 누수 해결
- **접근성 고려**: `prefers-reduced-motion` 자동 처리
- **타입 안전성**: TypeScript로 타입 안전한 애니메이션
- **일관성**: 모든 컴포넌트에서 동일한 애니메이션 패턴 적용

---

## 🏗️ 구조 개요

```
src/
├── lib/
│   └── animation-config.ts        # 통합 애니메이션 설정
├── hooks/
│   ├── useAnimation.ts           # 재사용 가능한 애니메이션 훅들
│   └── useSlider.ts              # 개선된 슬라이더 (레거시 호환)
└── components/
    └── ui/
        └── loading-animations.tsx # 로딩/에러 상태 컴포넌트
```

---

## 🎯 1. 기본 애니메이션 설정

### 애니메이션 설정 파일 (`animation-config.ts`)

```typescript
import { ANIMATION_CONFIG, ANIMATION_PRESETS } from '@/lib/animation-config'

// 기본 타이밍 설정
const duration = ANIMATION_CONFIG.duration.medium // 300ms
const easing = ANIMATION_CONFIG.easing.easeOut

// 프리셋 사용
const fadeInUp = ANIMATION_PRESETS.fadeInUp
```

### CSS 클래스 자동 생성

```typescript
import { createAnimationClasses } from '@/lib/animation-config'

// 지연 시간과 함께 애니메이션 클래스 생성
const animationClass = createAnimationClasses('fadeInUp', 200)
// 결과: "animate-fade-in-up animation-delay-200"
```

---

## 🎨 2. Hook 기반 애니메이션

### 뷰포트 진입 애니메이션

```typescript
import { useViewportAnimation } from '@/hooks/useAnimation'

function MyComponent() {
  const { elementRef, isVisible } = useViewportAnimation({
    threshold: 0.1,
    rootMargin: '50px',
    triggerOnce: true,
    delay: 200
  })

  return (
    <div 
      ref={elementRef} 
      className={isVisible ? 'animate-fade-in-up' : 'opacity-0'}
    >
      콘텐츠
    </div>
  )
}
```

### 스테이거 애니메이션 (순차 등장)

```typescript
import { useStaggerAnimation } from '@/hooks/useAnimation'

function CardGrid() {
  const { elementRef, isItemVisible } = useStaggerAnimation({
    itemCount: 3,
    staggerDelay: 200, // 0.2초씩 지연
    baseDelay: 100
  })

  return (
    <div ref={elementRef}>
      {cards.map((card, index) => (
        <div 
          key={index}
          className={isItemVisible(index) ? 'animate-fade-in-up' : 'opacity-0'}
        >
          {card.content}
        </div>
      ))}
    </div>
  )
}
```

### 호버 애니메이션

```typescript
import { useHoverAnimation } from '@/hooks/useAnimation'

function InteractiveCard() {
  const { elementRef, hoverStyles } = useHoverAnimation({
    scale: 1.05,
    duration: 300
  })

  return (
    <div 
      ref={elementRef as React.RefObject<HTMLDivElement>}
      style={hoverStyles}
      className="cursor-pointer"
    >
      호버 시 확대되는 카드
    </div>
  )
}
```

### 향상된 슬라이더

```typescript
import { useAdvancedSlider } from '@/hooks/useAnimation'

function ImageSlider() {
  const {
    sliderRef,
    currentIndex,
    canScrollLeft,
    canScrollRight,
    scrollLeft,
    scrollRight,
    handleMouseEnter,
    handleMouseLeave,
    toggleAutoPlay
  } = useAdvancedSlider({
    itemCount: 5,
    autoPlay: true,
    autoPlayInterval: 4000,
    infinite: true,
    itemWidth: 450,
    gap: 64,
    mobileItemWidth: 280,
    mobileGap: 16
  })

  return (
    <div 
      ref={sliderRef}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
      className="flex overflow-x-auto scrollbar-hide"
    >
      {/* 슬라이더 콘텐츠 */}
    </div>
  )
}
```

---

## 🔄 3. 로딩 및 상태 애니메이션

### 로딩 스피너

```typescript
import { LoadingSpinner } from '@/components/ui/loading-animations'

<LoadingSpinner size="lg" color="gold" />
```

### 로딩 점들

```typescript
import { LoadingDots } from '@/components/ui/loading-animations'

<LoadingDots size="md" color="primary" />
```

### 스켈레톤 로딩

```typescript
import { LoadingSkeleton } from '@/components/ui/loading-animations'

<LoadingSkeleton lines={3} height="h-4" />
```

### 풀스크린 로딩 오버레이

```typescript
import { LoadingOverlay } from '@/components/ui/loading-animations'

{isLoading && (
  <LoadingOverlay 
    message="데이터를 불러오는 중..."
    type="spinner"
  />
)}
```

### 에러 상태

```typescript
import { ErrorAnimation } from '@/components/ui/loading-animations'

<ErrorAnimation 
  message="데이터를 불러올 수 없습니다"
  onRetry={() => refetch()}
/>
```

---

## 🎪 4. 특수 효과 애니메이션

### 펄스 효과

```typescript
import { Pulse } from '@/components/ui/loading-animations'

<Pulse intensity="medium">
  <div>펄스 효과가 있는 콘텐츠</div>
</Pulse>
```

### 글로우 효과

```typescript
import { Glow } from '@/components/ui/loading-animations'

<Glow color="gold">
  <button>빛나는 버튼</button>
</Glow>
```

### 클릭 애니메이션

```typescript
import { ClickAnimation } from '@/components/ui/loading-animations'

<ClickAnimation effect="scale" onClick={handleClick}>
  <button>클릭하면 축소되는 버튼</button>
</ClickAnimation>
```

### 호버 글로우

```typescript
import { HoverGlow } from '@/components/ui/loading-animations'

<HoverGlow intensity="strong">
  <div>호버 시 빛나는 요소</div>
</HoverGlow>
```

---

## 🎨 5. CSS 애니메이션 클래스

### 기본 페이드 애니메이션
```css
.animate-fade-in          /* 기본 페이드인 */
.animate-fade-in-up       /* 위로 페이드인 */
.animate-fade-in-down     /* 아래로 페이드인 */
```

### 슬라이드 애니메이션
```css
.animate-slide-in-left    /* 왼쪽에서 슬라이드인 */
.animate-slide-in-right   /* 오른쪽에서 슬라이드인 */
```

### 스케일 애니메이션
```css
.animate-scale-in         /* 스케일로 등장 */
.animate-scale-bounce     /* 바운스하며 등장 */
```

### 특수 효과
```css
.animate-pulse-soft       /* 부드러운 펄스 */
.animate-glow             /* 글로우 효과 */
.animate-wave             /* 파도 효과 */
.animate-spin-slow        /* 느린 회전 */
```

### 지연 시간
```css
.animation-delay-100      /* 0.1초 지연 */
.animation-delay-200      /* 0.2초 지연 */
.animation-delay-300      /* 0.3초 지연 */
/* ... 0.8초까지 */
```

---

## 🎯 6. 접근성 고려사항

### 자동 모션 감소 처리

모든 애니메이션 컴포넌트와 훅은 자동으로 `prefers-reduced-motion` 설정을 확인합니다:

```typescript
import { shouldReduceMotion } from '@/lib/animation-config'

if (shouldReduceMotion()) {
  // 애니메이션 비활성화 또는 단순화
  return <StaticComponent />
}
```

### CSS에서의 모션 감소
```css
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}
```

---

## 🚀 7. 마이그레이션 가이드

### 기존 코드에서 새 시스템으로 변환

#### Before (기존 방식)
```typescript
const [isVisible, setIsVisible] = useState(false)

useEffect(() => {
  const observer = new IntersectionObserver(/* ... */)
  // 복잡한 observer 로직
}, [])

return (
  <div className={isVisible ? 'animate-fade-in-up animation-delay-200' : 'opacity-0'}>
    콘텐츠
  </div>
)
```

#### After (새로운 방식)
```typescript
const { elementRef, isVisible } = useViewportAnimation({ delay: 200 })

return (
  <div 
    ref={elementRef}
    className={isVisible ? 'animate-fade-in-up' : 'opacity-0'}
  >
    콘텐츠
  </div>
)
```

### 기존 슬라이더 코드
기존 `useSlider` 훅은 그대로 사용 가능합니다 (하위 호환성 유지):

```typescript
// 기존 코드 그대로 작동
import { useSlider } from '@/hooks/useSlider'

const { activeIndex, scrollLeft, scrollRight } = useSlider()
```

---

## 📊 8. 성능 개선사항

### Before vs After

| 항목 | 기존 시스템 | 새로운 시스템 |
|------|------------|-------------|
| 번들 크기 | 기본 CSS만 | 최적화된 설정 파일 |
| 메모리 사용량 | 컴포넌트별 observer | 통합 관리 |
| 재사용성 | 낮음 | 높음 |
| 유지보수성 | 어려움 | 쉬움 |
| 타입 안전성 | 부분적 | 완전함 |
| 접근성 | 수동 처리 | 자동 처리 |

### 성능 최적화 기법

1. **Intersection Observer 재사용**: 여러 요소가 같은 observer 사용
2. **메모화**: 불필요한 리렌더링 방지
3. **조건부 애니메이션**: 모션 감소 설정 시 애니메이션 비활성화
4. **CSS Transform 우선 사용**: GPU 가속 활용

---

## 🎉 9. 결론

새로운 애니메이션 시스템을 통해 다음을 달성했습니다:

### ✅ 해결된 문제들
- ❌ 분산된 애니메이션 로직 → ✅ 중앙집중식 관리
- ❌ 하드코딩된 설정값 → ✅ 재사용 가능한 설정
- ❌ 복잡한 슬라이더 구현 → ✅ 안정적이고 단순한 로직
- ❌ 일관성 부족 → ✅ 통일된 애니메이션 패턴
- ❌ 접근성 미고려 → ✅ 자동 접근성 처리

### 🚀 다음 단계 제안
1. **모니터링**: 실제 사용자 환경에서 성능 측정
2. **확장**: 추가 애니메이션 패턴 개발
3. **최적화**: 필요시 추가 성능 튜닝
4. **문서화**: 팀 내 사용법 공유 및 교육

이제 더 안정적이고 유지보수가 쉬운 애니메이션 시스템을 사용할 수 있습니다! 🎊 